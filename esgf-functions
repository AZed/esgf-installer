#!/bin/bash

#####
# esg-node: ESGF Node Application Stack
# chkconfig: 345 98 02
# description: Installer for the ESGF Node application stack
#
#****************************************************************************
#*                                                                          *
#*  Organization: Lawrence Livermore National Lab (LLNL)                    *
#*   Directorate: Computation                                               *
#*    Department: Computing Applications and Research                       *
#*	Division: S&T Global Security					                        *
#*	  Matrix: Atmospheric, Earth and Energy Division		                *
#*	 Program: PCMDI							                                *
#*	 Project: Earth Systems Grid Fed (ESGF) Node Software Stack	            *
#*  First Author: Gavin M. Bell (gavin@llnl.gov)			                *
#*									                                        *
#****************************************************************************
#*                                                                          *
#*   Copyright (c) 2009, Lawrence Livermore National Security, LLC.         *
#*   Produced at the Lawrence Livermore National Laboratory                 *
#*   Written by: Gavin M. Bell (gavin@llnl.gov)                             *
#*   LLNL-CODE-420962                                                       *
#*                                                                          *
#*   All rights reserved. This file is part of the:                         *
#*   Earth System Grid Fed (ESGF) Node Software Stack, Version 1.0          *
#*                                                                          *
#*   For details, see http://esgf.org/                                      *
#*   Please also read this link                                             *
#*    http://esgf.org/LICENSE                                               *
#*                                                                          *
#*   * Redistribution and use in source and binary forms, with or           *
#*   without modification, are permitted provided that the following	    *
#*   conditions are met:                                                    *
#*                                                                          *
#*   * Redistributions of source code must retain the above copyright       *
#*   notice, this list of conditions and the disclaimer below.              *
#*                                                                          *
#*   * Redistributions in binary form must reproduce the above copyright    *
#*   notice, this list of conditions and the disclaimer (as noted below)    *
#*   in the documentation and/or other materials provided with the	        *
#*   distribution.                                                          *
#*                                                                          *
#*   Neither the name of the LLNS/LLNL nor the names of its contributors    *
#*   may be used to endorse or promote products derived from this           * 
#*   software without specific prior written permission.                    *
#*                                                                          *
#*   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    *
#*   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT	    *
#*   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS	    *
#*   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL LAWRENCE    *
#*   LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR	    *
#*   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,           *
#*   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT	    *
#*   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF	    *
#*   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND    *
#*   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,	    *
#*   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT	    *
#*   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF	    *
#*   SUCH DAMAGE.                                                           *
#*                                                                          *
#****************************************************************************
#####

#uses: perl, awk, ifconfig, tar, wget, curl, su, useradd, groupadd,
#      id, chmod, chown, chgrp, cut, svn, mkdir, killall, java, egrep,
#      lsof, unlink, ln, pax, keytool, openssl, getent

#note: usage of readlink not macosx friendly :-( usage of useradd /
#      groupadd is RedHat/CentOS dependent :-(

check_version() {
    # This is the most commonly used "public" version checking
    # routine.  It delegates to check_version_helper() for the actual
    # comparison, which in turn delegates to other functions in a chain.
    #
    # Arguments:
    #   $1: a string containing executable to call with the argument
    #       "--version" or "-version" to find the version to check against
    #   $2: the minimum acceptable version string
    #   $3 (optional): the maximum acceptable version string
    #
    # Returns 0 if the detected version is within the specified
    # bounds, or if there were not even two arguments passed.
    #
    # Returns 1 if the detected version is not within the specified
    # bounds.
    #
    # Returns 2 if running the specified command with "--version" or
    # "-version" as an argument results in an error for both
    # (i.e. because the command could not be found, or because neither
    # "--version" nor "-version" is a valid argument)

    debug_print "\nDEBUG: check_version [$@]"
    [ -z "${2}" ] && return 0
    local min_version=${2}
    local max_version=${3}
    debug_print "min_version = [$min_version]"
    debug_print "max_version = [$max_version]"

    local version_tempfile=$(mktemp)
    $1 --version >& ${version_tempfile} || $1 -version >& ${version_tempfile}
    [ $? != 0 ] && echo && echo " WARNING: could not find a version from '$1'" && return 2

    local current_version=$(cat ${version_tempfile} 2>&1 | perl -ne '/(\d+\.+\d*\.*\d*[.-_@+#]*\d*).*/, print "$1 "' | tr -d "\"" | cut -d " " -f1,1)
    local current_version=$(_trimline ${current_version})
    debug_print "current_version = [$current_version]"

    check_version_helper "${current_version}" "${min_version}" "${max_version}"
    local ret=$?
    (($DEBUG2)) && echo "The return value from the call to helper function check_version_ is $ret"
    if [ $ret == 0 ] ; then
        rm -f ${version_tempfile}
        return 0
    fi

    printf "\nThe detected version of ${1} [${current_version}] is not between [${min_version}] and [${max_version}] \n"
    cat ${version_tempfile}
    rm -f ${version_tempfile}
    return 1
}

check_version_with() {
    # This is an alternate version of check_version() (see above)
    # where the second argument specifies the entire command string with
    # all arguments, pipes, etc. needed to result in a version number
    # to compare.
    #
    # Arguments:
    #   $1: a string containing the name of the program version to
    #       check (this is only used in debugging output)
    #   $2: the complete command to be passed to eval to produce the
    #       version string to test
    #   $3: the minimum acceptable version string
    #   $4 (optional): the maximum acceptable version string
    #
    # Returns 0 if the detected version is within the specified
    # bounds, or if at least three arguments were not passed
    #
    # Returns 1 if the detected version is not within the specified
    # bounds.
    #
    # Returns 2 if running the specified command results in an error

    debug_print "\nDEBUG: check_version_with  \$1='$1'"
    local app_name=${1}
    local version_command=${2:-"${app_name} --version"}
    local min_version=${3}
    local max_version=${4}
    debug_print "min_version = [$min_version]"
    debug_print "max_version = [$max_version]"

    [ -z "${3}" ] && return 0

    local current_version=$(eval ${version_command})
    if [ $? != 0 ] ; then
        echo " WARNING: Could not detect version of ${app_name##*/}"
        return 2
    fi
    local current_version=$(_trimline ${current_version})

    check_version_helper "${current_version}" "${min_version}" "${max_version}"
    local ret=$?
    debug_print " The return value from the call to helper function check_version_helper is $ret"
    [ $ret == 0 ] && return 0

    printf "\nThe detected version of ${app_name##*/} [${current_version}] is not between [${min_version}] and [${max_version}] \n"
    return 1
}

#For python module version checking
#Looking for __version__ var
check_module_version() {
    debug_print "\nDEBUG: check_module_version  \$1='$1'  \$2='$2'"
    local module_name=$1
    local min_version=$2

    local current_version=$(${cdat_home}/bin/python -c "import ${module_name}; print ${module_name}.__version__" 2> /dev/null)
    [ $? != 0 ] && echo " WARNING:(2) Could not detect version of ${module_name}" && return 2
    [ -z "${current_version}" ] && echo " WARNING:(1) Could not detect version of ${module_name}" && return 3

    check_version_helper "${current_version}" "${min_version}"
    local ret=$?
    debug_print " The return value from the call to helper function check_version_ is $ret"
    [ $ret == 0 ] && return 0

    printf "\nSorry, the detected version of $1 [${current_version}] is older than required minimum version [${min_version}] \n"
    return 1
}

get_current_webapp_version() {
    local webapp_name=$1
    local version_property=${2:-"Version"}
    local v=$(echo $(sed -n '/^'${version_property}':[ ]*\(.*\)/p' ${tomcat_install_dir}/webapps/${webapp_name}/META-INF/MANIFEST.MF | awk '{print $2}' | xargs 2> /dev/null))
    echo $v
    [ -n "${v}" ] && return 0 || return 1
}

check_webapp_version() {
    debug_print "\nDEBUG: check_webapp_version  \$1='$1'  \$2='$2'  \$3='$3'"
    local webapp_name=$1
    local min_version=$2
    local version_property=${3:-"Version"}

    [ ! -d "${tomcat_install_dir}/webapps/${webapp_name}" ] && echo " Web Application \"${webapp_name}\" is not present or cannot be detected!" && return 2

    local current_version=$(get_current_webapp_version ${webapp_name} ${version_property})
    local current_version=$(_trimline ${current_version})
    [ $? != 0 ] && echo " WARNING:(2) Could not detect version of ${webapp_name}" && return 3
    [ -z "${current_version}" ] && echo " WARNING:(1) Could not detect version of ${webapp_name}" && return 4

    check_version_helper "${current_version}" "${min_version}"
    local ret=$?
    debug_print " The return value from the call to check_version_helper is $ret"
    [ $ret == 0 ] && return 0

    printf "\nSorry, the detected version of $1 [${current_version}] is older than required minimum version [${min_version}] \n"
    return 1
}

#0ne-off version checking mechanism for applications where version number is in the name of the directory
#of the form "app_dir-<version_num>"
check_app_version() {
    debug_print "\nDEBUG: check_app_version  \$1='$1'  \$2='$2'"

    local app_dir=$1
    local min_version=$2

    local current_version=$(readlink -f ${tomcat_install_dir} | sed -ne 's/.*-\(.*\)$/\1/p')
    [ $? != 0 ] && echo " WARNING:(2) Could not detect version of ${app_dir##*/}" && return 2
    [ -z "${current_version}" ] && echo " WARNING:(1) Could not detect version of ${app_dir##*/}" && return 3

    check_version_helper "${current_version}" "${min_version}"
    local ret=$?
    debug_print " The return value from the call to helper function check_version_ is $ret"
    [ $ret == 0 ] && return 0

    printf "\nSorry, the detected version of ${app_dir##*/} [${current_version}] is older than required minimum version [${min_version}] \n"
    return 1
}


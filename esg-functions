#!/bin/bash

#####
# esgf-functions: ESGF Node Application Stack functions
#
#****************************************************************************
#*                                                                          *
#*  Organization: Lawrence Livermore National Lab (LLNL)                    *
#*   Directorate: Computation                                               *
#*    Department: Computing Applications and Research                       *
#*	Division: S&T Global Security					                        *
#*	  Matrix: Atmospheric, Earth and Energy Division		                *
#*	 Program: PCMDI							                                *
#*	 Project: Earth Systems Grid Fed (ESGF) Node Software Stack	            *
#*  First Author: Gavin M. Bell (gavin@llnl.gov)                            *
#*									                                        *
#****************************************************************************
#*                                                                          *
#*   Copyright (c) 2009, Lawrence Livermore National Security, LLC.         *
#*   Produced at the Lawrence Livermore National Laboratory                 *
#*   Written by: Gavin M. Bell (gavin@llnl.gov)                             *
#*   LLNL-CODE-420962                                                       *
#*                                                                          *
#*   All rights reserved. This file is part of the:                         *
#*   Earth System Grid Fed (ESGF) Node Software Stack, Version 1.0          *
#*                                                                          *
#*   For details, see http://esgf.org/                                      *
#*   Please also read this link                                             *
#*    http://esgf.org/LICENSE                                               *
#*                                                                          *
#*   * Redistribution and use in source and binary forms, with or           *
#*   without modification, are permitted provided that the following	    *
#*   conditions are met:                                                    *
#*                                                                          *
#*   * Redistributions of source code must retain the above copyright       *
#*   notice, this list of conditions and the disclaimer below.              *
#*                                                                          *
#*   * Redistributions in binary form must reproduce the above copyright    *
#*   notice, this list of conditions and the disclaimer (as noted below)    *
#*   in the documentation and/or other materials provided with the	        *
#*   distribution.                                                          *
#*                                                                          *
#*   Neither the name of the LLNS/LLNL nor the names of its contributors    *
#*   may be used to endorse or promote products derived from this           * 
#*   software without specific prior written permission.                    *
#*                                                                          *
#*   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    *
#*   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT	    *
#*   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS	    *
#*   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL LAWRENCE    *
#*   LIVERMORE NATIONAL SECURITY, LLC, THE U.S. DEPARTMENT OF ENERGY OR	    *
#*   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,           *
#*   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT	    *
#*   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF	    *
#*   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND    *
#*   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,	    *
#*   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT	    *
#*   OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF	    *
#*   SUCH DAMAGE.                                                           *
#*                                                                          *
#****************************************************************************
#####

#uses: perl, awk, ifconfig, tar, wget, curl, su, useradd, groupadd,
#      id, chmod, chown, chgrp, cut, svn, mkdir, killall, java, egrep,
#      lsof, unlink, ln, pax, keytool, openssl, getent

#note: usage of readlink not macosx friendly :-( usage of useradd /
#      groupadd is RedHat/CentOS dependent :-(

#Needed to reduce the number of commands when wanting to make a verbose conditional print
verbose_print() { ((VERBOSE)) && echo $@; return 0; }
debug_print() { ((DEBUG)) && echo -e $@ >&2; return 0; }

_trimline() {
	# Strips leading and trailing whitespace even if IFS is set, also
	# removing the final newline on every line of input (i.e. the
	# result of using this on a multi-line string will be a
	# single-line string with no space between the last word on one
	# line and the first word on the next, with no leading or trailing
	# whitespace)
	echo "$@" | perl -p -e 's/^\s+|\s+$//g';
}

_version_cmp() {
    # Takes two strings, splits them into epoch (before the last ':'),
    # version (between the last ':' and the first '-'), and release
    # (after the first '-'), and then calls _version_segment_cmp on
    # each part until a difference is found.
    #
    # Empty segments are replaced with "-1" so that an empty segment
    # can precede a non-empty segment when being passed to
    # _version_segment_cmp.  As with _version_segment_cmp, leading
    # zeroes will likely confuse comparison as this is still
    # fundamentally a string sort to allow strings like "3.0alpha1".
    #
    # If $1 > $2, prints 1.  If $1 < $2, prints -1.  If $1 = $2, prints 0.
    # Usage example:
    #   if [ "$(_version_cmp $MYVERSION 1:2.3.4-5)" -lt 0 ] ; then ...

    EPOCHA=(`echo $1 | perl -ne 'my ($part)=/(.*):.*/;print "$part\n"'`)
    EPOCHB=(`echo $2 | perl -ne 'my ($part)=/(.*):.*/;print "$part\n"'`)
    EPOCHA=${EPOCHA:-"-1"}
    EPOCHB=${EPOCHB:-"-1"}

    NONEPOCHA=(`echo $1 | perl -ne 'my ($part)=/(?:.*:)?(.*)/;print "$part\n"'`)
    NONEPOCHB=(`echo $2 | perl -ne 'my ($part)=/(?:.*:)?(.*)/;print "$part\n"'`)

    VERSIONA=(`echo $NONEPOCHA | perl -ne 'my ($part)=/([^-]*)/;print "$part\n"'`)
    VERSIONB=(`echo $NONEPOCHB | perl -ne 'my ($part)=/([^-]*)/;print "$part\n"'`)
    VERSIONA=${VERSIONA:-"-1"}
    VERSIONB=${VERSIONB:-"-1"}

    RELEASEA=(`echo $NONEPOCHA | perl -ne 'my ($part)=/[^-]*-(.*)/;print "$part\n"'`)
    RELEASEB=(`echo $NONEPOCHB | perl -ne 'my ($part)=/[^-]*-(.*)/;print "$part\n"'`)
    RELEASEA=${RELEASEA:-"-1"}
    RELEASEB=${RELEASEB:-"-1"}

    EPOCHCMP=$(_version_segment_cmp ${EPOCHA} ${EPOCHB})
    if [ ${EPOCHCMP} -ne 0 ] ; then
        echo ${EPOCHCMP}
    else
        VERSIONCMP=$(_version_segment_cmp ${VERSIONA} ${VERSIONB})
        if [ ${VERSIONCMP} -ne 0 ] ; then
            echo ${VERSIONCMP}
        else
            RELEASECMP=$(_version_segment_cmp ${RELEASEA} ${RELEASEB})
            if [ ${RELEASECMP} -ne 0 ] ; then
                echo ${RELEASECMP}
            else
                echo "0"
            fi
        fi
    fi
}

_version_segment_cmp() {
    # Takes two strings, splits them on each '.' into arrays, compares
    # array elements until a difference is found.
    #
    # If a third argument is specified, it will override the separator
    # '.' with whatever characters were specified.
    #
    # This doesn't take into account epoch or release strings (":" or
    # "-" segments).  If you want to compare versions in the format of
    # "1:2.3-4", use _version_cmp(), which calls this function.
    #
    # If the values for both array elements are purely numeric, a
    # numeric compare is done (to handle problems such as 9 > 10 or
    # 02 < 1 in a string compare), but if either value contains a
    # non-numeric value or is null a string compare is done.  Null
    # values are considered less than zero.
    #
    # If $1 > $2, prints 1.  If $1 < $2, prints -1.  If $1 = $2, prints 0.
    #
    # Usage example:
    #   if [ "$(_version_segment_cmp $MYVERSION 1.2.3)" -lt 0 ] ; then ...

    SEP=${3:-"."}

    VERSIONA=(`echo $1 | perl -pe "s/[$SEP]/ /g"`)
    VERSIONB=(`echo $2 | perl -pe "s/[$SEP]/ /g"`)

    if [ ${#VERSIONA[*]} -gt ${#VERSIONB[*]} ] ; then
        VERSIONLENGTH=${#VERSIONA[*]}
    else
        VERSIONLENGTH=${#VERSIONB[*]}
    fi

    for index in `seq 1 $VERSIONLENGTH` ; do
        if ( [ -z ${VERSIONA[$index]##*[!0-9]*} ] ||
             [ -z ${VERSIONB[$index]##*[!0-9]*} ] ) ; then
            # Non-numeric comparison
            if [[ ${VERSIONA[$index]} > ${VERSIONB[$index]} ]] ; then
                echo "1"
                return
            elif [[ ${VERSIONA[$index]} < ${VERSIONB[$index]} ]] ; then
                echo "-1"
                return
            fi
        else
            # Purely numeric comparison
            if (( ${VERSIONA[$index]:-0} > ${VERSIONB[$index]:-0} )) ; then
                echo "1"
                return
            elif (( ${VERSIONA[$index]:-0} < ${VERSIONB[$index]:-0} )) ; then
                echo "-1"
                return
            fi
        fi
    done
    echo "0"
}

#-------------------------------
# Version Checking Utility Functions
#-------------------------------

check_version_atleast() {
    # Takes the following arguments:
    #   $1: a string containing the version to test
    #   $2: the minimum acceptable version
    #
    # Returns 0 if the first argument is greater than or equal to the
    # second and 1 otherwise.
    #
    # Returns 255 if called with less than two arguments.

    debug_print "DEBUG: check_version_atleast \$1='$1'  \$2='$2'"

    if [[ -z "${1}" || -z "${2}" ]] ; then
        echo "CRITICAL FAILURE: check_version_atleast called with insufficient arguments" >&2
        echo "  (\$1='$1'  \$2='$2')" >&2
        return 255
    fi

    if [ "$(_version_cmp ${1} ${2})" -ge 0 ] ; then return 0 ; fi
    return 1;
}

check_version_between() {
    # Takes the following arguments:
    #   $1: a string containing the version to test
    #   $2: the minimum acceptable version
    #   $3: the maximum acceptable version
    #
    # Returns 0 if the tested version is in the acceptable range
    # (greater than or equal to the second argument, and less than or
    # equal to the third), and 1 otherwise.
    #
    # Returns 255 if called with less than three arguments.

    debug_print "DEBUG: check_version_between \$1='$1'  \$2='$2'  \$3='$3'"

    if [[ -z "${1}" || -z "${2}" || -z "${3}" ]] ; then
        echo "CRITICAL FAILURE: check_version_between called with insufficient arguments" >&2
        echo "  (\$1='$1'  \$2='$2'  \$3='$3')" >&2
        return 255
    fi

    if [ "$(_version_cmp ${1} ${2})" -ge 0 ] \
        && [ "$(_version_cmp ${1} ${3})" -le 0 ] ; then
        return 0 ;
    fi
    return 1;
}

check_version_helper() {
    # Primary helper method for verifying version constraints,
    # automatically detecting by argument count whether to check for a
    # minimum version or a range.
    #    
    # Takes the following arguments:
    #   $1: a string containing the version to test
    #   $2: the minimum acceptable version
    #   $3 (optional): the maximum acceptable version
    #    
    # If called with only one argument, the function will attempt to
    # split it on spaces into multiple arguments automatically, and
    # then follow the above argument logic.
    #    
    # Returns 0 if the tested version is in the acceptable range
    #    
    # Returns 255 if less than two arguments are detected after
    # automatic argument splitting.

    debug_print "DEBUG: check_version_helper \$1='$1'  \$2='$2'  \$3='$3'"

    # Split a lone argument
    [[ $# == 1 ]] && set -- $1

    # Spit out a nasty error message and return with 255 if there are
    # insufficient arguments (this causes the version check to fail,
    # but does NOT abort the script -- watch for the CRITICAL FAILURE
    # string in your output)
    if [[  -z "${1}" || -z "${2}"  ]]; then 
        echo "CRITICAL FAILURE: check_version_between called with insufficient arguments" >&2
        echo "  (\$1='$1'  \$2='$2'  \$3='$3')" >&2
        return 255
    fi   

    if [ -z "${3}" ] ; then 
        # Only two arguments, check for a minimum version
        check_version_atleast ${1} ${2} 
        return $?
    fi   
    check_version_between ${1} ${2} ${3} 
    return $?
}

#--------------------------------------------------------------------------

check_version() {
    # This is the most commonly used "public" version checking
    # routine.  It delegates to check_version_helper() for the actual
    # comparison, which in turn delegates to other functions in a chain.
    #
    # Arguments:
    #   $1: a string containing executable to call with the argument
    #       "--version" or "-version" to find the version to check against
    #   $2: the minimum acceptable version string
    #   $3 (optional): the maximum acceptable version string
    #
    # Returns 0 if the detected version is within the specified
    # bounds, or if there were not even two arguments passed.
    #
    # Returns 1 if the detected version is not within the specified
    # bounds.
    #
    # Returns 2 if running the specified command with "--version" or
    # "-version" as an argument results in an error for both
    # (i.e. because the command could not be found, or because neither
    # "--version" nor "-version" is a valid argument)

    debug_print "\nDEBUG: check_version [$@]"
    [ -z "${2}" ] && return 0
    local min_version=${2}
    local max_version=${3}
    debug_print "min_version = [$min_version]"
    debug_print "max_version = [$max_version]"

    local version_tempfile=$(mktemp)
    $1 --version >& ${version_tempfile} || $1 -version >& ${version_tempfile}
    [ $? != 0 ] && echo && echo " WARNING: could not find a version from '$1'" && return 2

    local current_version=$(cat ${version_tempfile} 2>&1 | perl -ne '/(\d+\.+\d*\.*\d*[.-_@+#]*\d*).*/, print "$1 "' | tr -d "\"" | cut -d " " -f1,1)
    local current_version=$(_trimline ${current_version})
    debug_print "current_version = [$current_version]"

    check_version_helper "${current_version}" "${min_version}" "${max_version}"
    local ret=$?
    (($DEBUG2)) && echo "The return value from the call to helper function check_version_ is $ret"
    if [ $ret == 0 ] ; then
        rm -f ${version_tempfile}
        return 0
    fi

    printf "\nThe detected version of ${1} [${current_version}] is not between [${min_version}] and [${max_version}] \n"
    cat ${version_tempfile}
    rm -f ${version_tempfile}
    return 1
}

check_version_with() {
    # This is an alternate version of check_version() (see above)
    # where the second argument specifies the entire command string with
    # all arguments, pipes, etc. needed to result in a version number
    # to compare.
    #
    # Arguments:
    #   $1: a string containing the name of the program version to
    #       check (this is only used in debugging output)
    #   $2: the complete command to be passed to eval to produce the
    #       version string to test
    #   $3: the minimum acceptable version string
    #   $4 (optional): the maximum acceptable version string
    #
    # Returns 0 if the detected version is within the specified
    # bounds, or if at least three arguments were not passed
    #
    # Returns 1 if the detected version is not within the specified
    # bounds.
    #
    # Returns 2 if running the specified command results in an error

    debug_print "\nDEBUG: check_version_with  \$1='$1'"
    local app_name=${1}
    local version_command=${2:-"${app_name} --version"}
    local min_version=${3}
    local max_version=${4}
    debug_print "min_version = [$min_version]"
    debug_print "max_version = [$max_version]"

    [ -z "${3}" ] && return 0

    local current_version=$(eval ${version_command})
    if [ -z "${current_version}" ] || [ $? != 0 ] ; then
        echo " WARNING: Could not detect version of ${app_name##*/}"
        return 2
    fi
    local current_version=$(_trimline ${current_version})

    check_version_helper "${current_version}" "${min_version}" "${max_version}"
    local ret=$?
    debug_print " The return value from the call to helper function check_version_helper is $ret"
    [ $ret == 0 ] && return 0

    printf "\nThe detected version of ${app_name##*/} [${current_version}] is not between [${min_version}] and [${max_version}] \n"
    return 1
}

#For python module version checking
#Looking for __version__ var
check_module_version() {
    debug_print "\nDEBUG: check_module_version  \$1='$1'  \$2='$2'"
    local module_name=$1
    local min_version=$2

    local current_version=$(${cdat_home}/bin/python -c "import ${module_name}; print ${module_name}.__version__" 2> /dev/null)
    [ $? != 0 ] && echo " WARNING:(2) Could not detect version of ${module_name}" && return 2
    [ -z "${current_version}" ] && echo " WARNING:(1) Could not detect version of ${module_name}" && return 3

    check_version_helper "${current_version}" "${min_version}"
    local ret=$?
    debug_print " The return value from the call to helper function check_version_ is $ret"
    [ $ret == 0 ] && return 0

    printf "\nSorry, the detected version of $1 [${current_version}] is older than required minimum version [${min_version}] \n"
    return 1
}

get_current_webapp_version() {
    local webapp_name=$1
    local version_property=${2:-"Version"}
    local v=$(echo $(sed -n '/^'${version_property}':[ ]*\(.*\)/p' ${tomcat_install_dir}/webapps/${webapp_name}/META-INF/MANIFEST.MF | awk '{print $2}' | xargs 2> /dev/null))
    echo $v
    [ -n "${v}" ] && return 0 || return 1
}

check_webapp_version() {
    debug_print "\nDEBUG: check_webapp_version  \$1='$1'  \$2='$2'  \$3='$3'"
    local webapp_name=$1
    local min_version=$2
    local version_property=${3:-"Version"}

    [ ! -d "${tomcat_install_dir}/webapps/${webapp_name}" ] && echo " Web Application \"${webapp_name}\" is not present or cannot be detected!" && return 2

    local current_version=$(get_current_webapp_version ${webapp_name} ${version_property})
    local current_version=$(_trimline ${current_version})
    [ $? != 0 ] && echo " WARNING:(2) Could not detect version of ${webapp_name}" && return 3
    [ -z "${current_version}" ] && echo " WARNING:(1) Could not detect version of ${webapp_name}" && return 4

    check_version_helper "${current_version}" "${min_version}"
    local ret=$?
    debug_print " The return value from the call to check_version_helper is $ret"
    [ $ret == 0 ] && return 0

    printf "\nSorry, the detected version of $1 [${current_version}] is older than required minimum version [${min_version}] \n"
    return 1
}

#0ne-off version checking mechanism for applications where version number is in the name of the directory
#of the form "app_dir-<version_num>"
check_app_version() {
    debug_print "\nDEBUG: check_app_version  \$1='$1'  \$2='$2'"

    local app_dir=$1
    local min_version=$2

    local current_version=$(readlink -f ${tomcat_install_dir} | sed -ne 's/.*-\(.*\)$/\1/p')
    [ $? != 0 ] && echo " WARNING:(2) Could not detect version of ${app_dir##*/}" && return 2
    [ -z "${current_version}" ] && echo " WARNING:(1) Could not detect version of ${app_dir##*/}" && return 3

    check_version_helper "${current_version}" "${min_version}"
    local ret=$?
    debug_print " The return value from the call to helper function check_version_ is $ret"
    [ $ret == 0 ] && return 0

    printf "\nSorry, the detected version of ${app_dir##*/} [${current_version}] is older than required minimum version [${min_version}] \n"
    return 1
}

#----------------------------------------------------------
# Environment Management Utility Functions
#----------------------------------------------------------
remove_env() {
	local key=${1}
	((DEBUG)) && echo "removing ${key}'s environment from ${envfile}"
	sed -i '/'${key}'/d' ${envfile}
	return $?
}

remove_install_log_entry() {
    local key=${1}
    ((DEBUG)) && echo "removing ${key}'s install log entry from ${install_manifest}"
    sed -i '/[:]\?'${key}'=/d' ${install_manifest}
    return $?
}

# Environment variable files of the form
# Ex: export FOOBAR=some_value
# Will have duplcate keys removed such that the
# last entry of that variable is the only one present
# in the final output.
# arg 1 - The environment file to dedup.
dedup() {
    local infile=${1:-${envfile}}
    [ ! -e "${infile}" ] && echo "WARNING: dedup() - unable to locate ${infile} does it exist?" && return 1
    [ ! -w "${infile}" ] && echo "WARNING: dedup() - unable to write to ${infile}" && return 1
    local tmp=$(tac ${infile} | awk 'BEGIN {FS="[ =]"} !($2 in a) {a[$2];print $0}' | sort -k2,2)
    echo "$tmp" > ${infile}
}

dedup_properties() {
    local infile=${1:-${config_file}}
    [ ! -e "${infile}" ] && echo "WARNING: dedup_properties() - unable to locate ${infile} does it exist?" && return 1
    [ ! -w "${infile}" ] && echo "WARNING: dedup_properties() - unable to write to ${infile}" && return 1
    local tmp=$(tac ${infile} | awk 'BEGIN {FS="[ =]"} !($1 in a) {a[$1];print $0}' | sort -k1,1)
    echo "$tmp" > ${infile}
}

#####
# Get Current IP Address - Needed (at least temporarily) for Mesos Master
####

get_config_ip() { 
	/sbin/ifconfig $1 | grep "inet addr" | awk -F: '{print $2}' | awk '{print $1}'; 
}
